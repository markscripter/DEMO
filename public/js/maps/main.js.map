{"version":3,"names":[],"mappings":"","sources":["main.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar stampit = require('stampit');\nvar menu = require('./modules/menu.js');\n\n// get base stamp (prototype)\nvar Menu = stampit.compose(menu);\n\n// instantiate main menu\nvar mainMenu = Menu();\nmainMenu.init(document.querySelector('.main'));\n\n// instantiate utility menu\nvar utilityMenu = Menu();\nutilityMenu.init(document.querySelector('.utility'));\n\n},{\"./modules/menu.js\":2,\"stampit\":21}],2:[function(require,module,exports){\n'use strict';\nvar stampit = require('stampit');\n\nmodule.exports = stampit().enclose(function () {\n  var el = undefined;\n  var trigger = undefined;\n  var content = undefined;\n  var isHidden = undefined;\n\n  this.toggelMenu = function toggelMenu(e) {\n    if (content.hasAttribute('aria-hidden')) {\n      isHidden = content.attributes['aria-hidden'].textContent;\n      if (isHidden === 'true') {\n        content.attributes['aria-hidden'].textContent = false;\n        e.preventDefault();\n\n        // setup binding to close menu when anything but menu is clicked\n        document.querySelector('body').addEventListener('click', function (e) {\n          if (!e.defaultPrevented) {\n            content.attributes['aria-hidden'].textContent = true;\n          }\n        });\n      } else {\n        content.attributes['aria-hidden'].textContent = true;\n      }\n    }\n  };\n\n  this.bindContent = function bindContent(el) {\n    if (!el) {\n      return;\n    }\n    trigger = el.querySelector('.menu-trigger');\n    content = el.querySelector('.menu-content');\n\n    trigger.addEventListener('click', this.toggelMenu);\n  };\n\n  return stampit.mixIn(this, {\n    init: function init(elem) {\n      if (!elem) {\n        return;\n      }\n      el = elem;\n      this.bindContent(el);\n    }\n  });\n});\n\n},{\"stampit\":21}],3:[function(require,module,exports){\nvar forIn = require('mout/object/forIn');\n\nfunction copyProp(val, key){\n    this[key] = val;\n}\n\nmodule.exports = function mixInChain(target, objects){\n    var i = 0,\n        n = arguments.length,\n        obj;\n    while(++i < n){\n        obj = arguments[i];\n        if (obj != null) {\n            forIn(obj, copyProp, target);\n        }\n    }\n    return target;\n};\n\n},{\"mout/object/forIn\":16}],4:[function(require,module,exports){\n\n\n    /**\n     * Array forEach\n     */\n    function forEach(arr, callback, thisObj) {\n        if (arr == null) {\n            return;\n        }\n        var i = -1,\n            len = arr.length;\n        while (++i < len) {\n            // we iterate over sparse items since there is no way to make it\n            // work properly on IE 7-8. see #64\n            if ( callback.call(thisObj, arr[i], i, arr) === false ) {\n                break;\n            }\n        }\n    }\n\n    module.exports = forEach;\n\n\n\n},{}],5:[function(require,module,exports){\nvar forEach = require('./forEach');\nvar makeIterator = require('../function/makeIterator_');\n\n    /**\n     * Array map\n     */\n    function map(arr, callback, thisObj) {\n        callback = makeIterator(callback, thisObj);\n        var results = [];\n        if (arr == null){\n            return results;\n        }\n\n        var i = -1, len = arr.length;\n        while (++i < len) {\n            results[i] = callback(arr[i], i, arr);\n        }\n\n        return results;\n    }\n\n     module.exports = map;\n\n\n},{\"../function/makeIterator_\":6,\"./forEach\":4}],6:[function(require,module,exports){\nvar prop = require('./prop');\nvar deepMatches = require('../object/deepMatches');\n\n    /**\n     * Converts argument into a valid iterator.\n     * Used internally on most array/object/collection methods that receives a\n     * callback/iterator providing a shortcut syntax.\n     */\n    function makeIterator(src, thisObj){\n        switch(typeof src) {\n            case 'object':\n                // typeof null == \"object\"\n                return (src != null)? function(val, key, target){\n                    return deepMatches(val, src);\n                } : src;\n            case 'string':\n            case 'number':\n                return prop(src);\n            case 'function':\n                if (typeof thisObj === 'undefined') {\n                    return src;\n                } else {\n                    return function(val, i, arr){\n                        return src.call(thisObj, val, i, arr);\n                    };\n                }\n            default:\n                return src;\n        }\n    }\n\n    module.exports = makeIterator;\n\n\n\n},{\"../object/deepMatches\":15,\"./prop\":7}],7:[function(require,module,exports){\n\n\n    /**\n     * Returns a function that gets a property of the passed object\n     */\n    function prop(name){\n        return function(obj){\n            return obj[name];\n        };\n    }\n\n    module.exports = prop;\n\n\n\n},{}],8:[function(require,module,exports){\nvar kindOf = require('./kindOf');\nvar isPlainObject = require('./isPlainObject');\nvar mixIn = require('../object/mixIn');\n\n    /**\n     * Clone native types.\n     */\n    function clone(val){\n        switch (kindOf(val)) {\n            case 'Object':\n                return cloneObject(val);\n            case 'Array':\n                return cloneArray(val);\n            case 'RegExp':\n                return cloneRegExp(val);\n            case 'Date':\n                return cloneDate(val);\n            default:\n                return val;\n        }\n    }\n\n    function cloneObject(source) {\n        if (isPlainObject(source)) {\n            return mixIn({}, source);\n        } else {\n            return source;\n        }\n    }\n\n    function cloneRegExp(r) {\n        var flags = '';\n        flags += r.multiline ? 'm' : '';\n        flags += r.global ? 'g' : '';\n        flags += r.ignorecase ? 'i' : '';\n        return new RegExp(r.source, flags);\n    }\n\n    function cloneDate(date) {\n        return new Date(+date);\n    }\n\n    function cloneArray(arr) {\n        return arr.slice();\n    }\n\n    module.exports = clone;\n\n\n\n},{\"../object/mixIn\":20,\"./isPlainObject\":13,\"./kindOf\":14}],9:[function(require,module,exports){\nvar clone = require('./clone');\nvar forOwn = require('../object/forOwn');\nvar kindOf = require('./kindOf');\nvar isPlainObject = require('./isPlainObject');\n\n    /**\n     * Recursively clone native types.\n     */\n    function deepClone(val, instanceClone) {\n        switch ( kindOf(val) ) {\n            case 'Object':\n                return cloneObject(val, instanceClone);\n            case 'Array':\n                return cloneArray(val, instanceClone);\n            default:\n                return clone(val);\n        }\n    }\n\n    function cloneObject(source, instanceClone) {\n        if (isPlainObject(source)) {\n            var out = {};\n            forOwn(source, function(val, key) {\n                this[key] = deepClone(val, instanceClone);\n            }, out);\n            return out;\n        } else if (instanceClone) {\n            return instanceClone(source);\n        } else {\n            return source;\n        }\n    }\n\n    function cloneArray(arr, instanceClone) {\n        var out = [],\n            i = -1,\n            n = arr.length,\n            val;\n        while (++i < n) {\n            out[i] = deepClone(arr[i], instanceClone);\n        }\n        return out;\n    }\n\n    module.exports = deepClone;\n\n\n\n\n},{\"../object/forOwn\":17,\"./clone\":8,\"./isPlainObject\":13,\"./kindOf\":14}],10:[function(require,module,exports){\nvar isKind = require('./isKind');\n    /**\n     */\n    var isArray = Array.isArray || function (val) {\n        return isKind(val, 'Array');\n    };\n    module.exports = isArray;\n\n\n},{\"./isKind\":11}],11:[function(require,module,exports){\nvar kindOf = require('./kindOf');\n    /**\n     * Check if value is from a specific \"kind\".\n     */\n    function isKind(val, kind){\n        return kindOf(val) === kind;\n    }\n    module.exports = isKind;\n\n\n},{\"./kindOf\":14}],12:[function(require,module,exports){\nvar isKind = require('./isKind');\n    /**\n     */\n    function isObject(val) {\n        return isKind(val, 'Object');\n    }\n    module.exports = isObject;\n\n\n},{\"./isKind\":11}],13:[function(require,module,exports){\n\n\n    /**\n     * Checks if the value is created by the `Object` constructor.\n     */\n    function isPlainObject(value) {\n        return (!!value\n            && typeof value === 'object'\n            && value.constructor === Object);\n    }\n\n    module.exports = isPlainObject;\n\n\n\n},{}],14:[function(require,module,exports){\n\n\n    var _rKind = /^\\[object (.*)\\]$/,\n        _toString = Object.prototype.toString,\n        UNDEF;\n\n    /**\n     * Gets the \"kind\" of value. (e.g. \"String\", \"Number\", etc)\n     */\n    function kindOf(val) {\n        if (val === null) {\n            return 'Null';\n        } else if (val === UNDEF) {\n            return 'Undefined';\n        } else {\n            return _rKind.exec( _toString.call(val) )[1];\n        }\n    }\n    module.exports = kindOf;\n\n\n},{}],15:[function(require,module,exports){\nvar forOwn = require('./forOwn');\nvar isArray = require('../lang/isArray');\n\n    function containsMatch(array, pattern) {\n        var i = -1, length = array.length;\n        while (++i < length) {\n            if (deepMatches(array[i], pattern)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function matchArray(target, pattern) {\n        var i = -1, patternLength = pattern.length;\n        while (++i < patternLength) {\n            if (!containsMatch(target, pattern[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function matchObject(target, pattern) {\n        var result = true;\n        forOwn(pattern, function(val, key) {\n            if (!deepMatches(target[key], val)) {\n                // Return false to break out of forOwn early\n                return (result = false);\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * Recursively check if the objects match.\n     */\n    function deepMatches(target, pattern){\n        if (target && typeof target === 'object') {\n            if (isArray(target) && isArray(pattern)) {\n                return matchArray(target, pattern);\n            } else {\n                return matchObject(target, pattern);\n            }\n        } else {\n            return target === pattern;\n        }\n    }\n\n    module.exports = deepMatches;\n\n\n\n},{\"../lang/isArray\":10,\"./forOwn\":17}],16:[function(require,module,exports){\n\n\n    var _hasDontEnumBug,\n        _dontEnums;\n\n    function checkDontEnum(){\n        _dontEnums = [\n                'toString',\n                'toLocaleString',\n                'valueOf',\n                'hasOwnProperty',\n                'isPrototypeOf',\n                'propertyIsEnumerable',\n                'constructor'\n            ];\n\n        _hasDontEnumBug = true;\n\n        for (var key in {'toString': null}) {\n            _hasDontEnumBug = false;\n        }\n    }\n\n    /**\n     * Similar to Array/forEach but works over object properties and fixes Don't\n     * Enum bug on IE.\n     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\n     */\n    function forIn(obj, fn, thisObj){\n        var key, i = 0;\n        // no need to check if argument is a real object that way we can use\n        // it for arrays, functions, date, etc.\n\n        //post-pone check till needed\n        if (_hasDontEnumBug == null) checkDontEnum();\n\n        for (key in obj) {\n            if (exec(fn, obj, key, thisObj) === false) {\n                break;\n            }\n        }\n\n        if (_hasDontEnumBug) {\n            while (key = _dontEnums[i++]) {\n                // since we aren't using hasOwn check we need to make sure the\n                // property was overwritten\n                if (obj[key] !== Object.prototype[key]) {\n                    if (exec(fn, obj, key, thisObj) === false) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function exec(fn, obj, key, thisObj){\n        return fn.call(thisObj, obj[key], key, obj);\n    }\n\n    module.exports = forIn;\n\n\n\n},{}],17:[function(require,module,exports){\nvar hasOwn = require('./hasOwn');\nvar forIn = require('./forIn');\n\n    /**\n     * Similar to Array/forEach but works over object properties and fixes Don't\n     * Enum bug on IE.\n     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\n     */\n    function forOwn(obj, fn, thisObj){\n        forIn(obj, function(val, key){\n            if (hasOwn(obj, key)) {\n                return fn.call(thisObj, obj[key], key, obj);\n            }\n        });\n    }\n\n    module.exports = forOwn;\n\n\n\n},{\"./forIn\":16,\"./hasOwn\":18}],18:[function(require,module,exports){\n\n\n    /**\n     * Safer Object.hasOwnProperty\n     */\n     function hasOwn(obj, prop){\n         return Object.prototype.hasOwnProperty.call(obj, prop);\n     }\n\n     module.exports = hasOwn;\n\n\n\n},{}],19:[function(require,module,exports){\nvar hasOwn = require('./hasOwn');\nvar deepClone = require('../lang/deepClone');\nvar isObject = require('../lang/isObject');\n\n    /**\n     * Deep merge objects.\n     */\n    function merge() {\n        var i = 1,\n            key, val, obj, target;\n\n        // make sure we don't modify source element and it's properties\n        // objects are passed by reference\n        target = deepClone( arguments[0] );\n\n        while (obj = arguments[i++]) {\n            for (key in obj) {\n                if ( ! hasOwn(obj, key) ) {\n                    continue;\n                }\n\n                val = obj[key];\n\n                if ( isObject(val) && isObject(target[key]) ){\n                    // inception, deep merge objects\n                    target[key] = merge(target[key], val);\n                } else {\n                    // make sure arrays, regexp, date, objects are cloned\n                    target[key] = deepClone(val);\n                }\n\n            }\n        }\n\n        return target;\n    }\n\n    module.exports = merge;\n\n\n\n},{\"../lang/deepClone\":9,\"../lang/isObject\":12,\"./hasOwn\":18}],20:[function(require,module,exports){\nvar forOwn = require('./forOwn');\n\n    /**\n    * Combine properties from all the objects into first one.\n    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.\n    * @param {object} target    Target Object\n    * @param {...object} objects    Objects to be combined (0...n objects).\n    * @return {object} Target Object.\n    */\n    function mixIn(target, objects){\n        var i = 0,\n            n = arguments.length,\n            obj;\n        while(++i < n){\n            obj = arguments[i];\n            if (obj != null) {\n                forOwn(obj, copyProp, target);\n            }\n        }\n        return target;\n    }\n\n    function copyProp(val, key){\n        this[key] = val;\n    }\n\n    module.exports = mixIn;\n\n\n},{\"./forOwn\":17}],21:[function(require,module,exports){\n/**\n * Stampit\n **\n * Create objects from reusable, composable behaviors.\n **\n * Copyright (c) 2013 Eric Elliott\n * http://opensource.org/licenses/MIT\n **/\n'use strict';\nvar forEach = require('mout/array/forEach');\nvar mixIn = require('mout/object/mixIn');\nvar merge = require('mout/object/merge');\nvar map = require('mout/array/map');\nvar forOwn = require('mout/object/forOwn');\nvar mixInChain = require('./mixinchain.js');\nvar slice = [].slice;\n\n// Avoiding JSHist W003 violations.\nvar create, extractFunctions, stampit, compose, isStamp, convertConstructor;\n\ncreate = function (o) {\n  if (arguments.length > 1) {\n    throw new Error('Object.create implementation only accepts the first parameter.');\n  }\n  function F() {}\n\n  F.prototype = o;\n  return new F();\n};\n\nif (!Array.isArray) {\n  Array.isArray = function (vArg) {\n    return Object.prototype.toString.call(vArg) === \"[object Array]\";\n  };\n}\n\nextractFunctions = function extractFunctions(arg) {\n  if (typeof arg === 'function') {\n    return map(slice.call(arguments), function (fn) {\n      if (typeof fn === 'function') {\n        return fn;\n      }\n    });\n  } else if (typeof arg === 'object') {\n    var arr = [];\n    forEach(slice.call(arguments), function (obj) {\n      forOwn(obj, function (fn) {\n        arr.push(fn);\n      });\n    });\n    return arr;\n  } else if (Array.isArray(arg)) {\n    return slice.call(arg);\n  }\n  return [];\n};\n\n/**\n * Return a factory function that will produce new objects using the\n * prototypes that are passed in or composed.\n *\n * @param  {Object} [methods] A map of method names and bodies for delegation.\n * @param  {Object} [state]   A map of property names and values to clone for each new object.\n * @param  {Function} [enclose] A closure (function) used to create private data and privileged methods.\n * @return {Function} factory A factory to produce objects using the given prototypes.\n * @return {Function} factory.create Just like calling the factory function.\n * @return {Object} factory.fixed An object map containing the fixed prototypes.\n * @return {Function} factory.methods Add methods to the methods prototype. Chainable.\n * @return {Function} factory.state Add properties to the state prototype. Chainable.\n * @return {Function} factory.enclose Add or replace the closure prototype. Not chainable.\n */\nstampit = function stampit(methods, state, enclose) {\n  var fixed = {\n      methods: methods || {},\n      state: state,\n      enclose: extractFunctions(enclose)\n    },\n\n    factory = function factory(properties) {\n      var state = merge({}, fixed.state),\n        instance = mixIn(create(fixed.methods || {}),\n          state, properties),\n        closures = fixed.enclose,\n        args = slice.call(arguments, 1);\n\n      forEach(closures, function (fn) {\n        if (typeof fn === 'function') {\n          instance = fn.apply(instance, args) || instance;\n        }\n      });\n\n      return instance;\n    };\n\n  return mixIn(factory, {\n    create: factory,\n    fixed: fixed,\n    /**\n     * Take n objects and add them to the methods prototype.\n     * @return {Object} stamp  The factory in question (`this`).\n     */\n    methods: function stampMethods() {\n      var obj = fixed.methods || {},\n        args = [obj].concat(slice.call(arguments));\n      fixed.methods = mixInChain.apply(this, args);\n      return this;\n    },\n    /**\n     * Take n objects and add them to the state prototype.\n     * @return {Object} stamp  The factory in question (`this`).\n     */\n    state: function stampState() {\n      var obj = fixed.state || {},\n        args = [obj].concat(slice.call(arguments));\n      fixed.state = mixIn.apply(this, args);\n      return this;\n    },\n    /**\n     * Take n functions, an array of functions, or n objects and add\n     * the functions to the enclose prototype.\n     * @return {Object} The factory in question (`this`).\n     */\n    enclose: function stampEnclose() {\n      fixed.enclose = fixed.enclose\n        .concat(extractFunctions.apply(null, arguments));\n      return this;\n    },\n    /**\n     * Take one or more factories produced from stampit() and\n     * combine them with `this` to produce and return a new factory.\n     * Combining overrides properties with last-in priority.\n     * @param {[Function]|...Function} factories Stampit factories.\n     * @return {Function} A new stampit factory composed from arguments.\n     */\n    compose: function (factories) {\n      var args = Array.isArray(factories) ? factories : slice.call(arguments);\n      args = [this].concat(args);\n      return compose(args);\n    }\n  });\n};\n\n/**\n * Take two or more factories produced from stampit() and\n * combine them to produce a new factory.\n * Combining overrides properties with last-in priority.\n * @param {[Function]|...Function} factories A factory produced by stampit().\n * @return {Function} A new stampit factory composed from arguments.\n */\ncompose = function compose(factories) {\n  factories = Array.isArray(factories) ? factories : slice.call(arguments);\n  var result = stampit(),\n    f = result.fixed;\n  forEach(factories, function (source) {\n    if (source && source.fixed) {\n      if (source.fixed.methods) {\n        f.methods = mixInChain(f.methods, source.fixed.methods);\n      }\n\n      if (source.fixed.state) {\n        f.state = mixIn(f.state || {}, source.fixed.state);\n      }\n\n      if (source.fixed.enclose) {\n        f.enclose = f.enclose.concat(source.fixed.enclose);\n      }\n    }\n  });\n  return result;\n};\n\n/**\n * Check if an object is a stamp.\n * @param {Object} obj An object to check.\n * @returns {Boolean}\n */\nisStamp = function isStamp(obj) {\n  return (\n    typeof obj === 'function' &&\n    typeof obj.fixed === 'object' &&\n    typeof obj.methods === 'function' &&\n    typeof obj.state === 'function' &&\n    typeof obj.enclose === 'function'\n    );\n};\n\n/**\n * Take an old-fashioned JS constructor and return a stampit stamp\n * that you can freely compose with other stamps.\n * @param  {Function} Constructor\n * @return {Function}             A composable stampit factory\n *                                (aka stamp).\n */\nconvertConstructor = function convertConstructor(Constructor) {\n  return stampit().methods(Constructor.prototype).enclose(Constructor);\n};\n\nmodule.exports = mixIn(stampit, {\n  compose: compose,\n  /**\n   * Alias for mixIn\n   */\n  extend: mixIn,\n  /**\n   * Take a destination object followed by one or more source objects,\n   * and copy the source object properties to the destination object,\n   * with last in priority overrides.\n   * @param {Object} destination An object to copy properties to.\n   * @param {...Object} source An object to copy properties from.\n   * @returns {Object}\n   */\n  mixIn: mixIn,\n  /**\n   * Check if an object is a stamp.\n   * @param {Object} obj An object to check.\n   * @returns {Boolean}\n   */\n  isStamp: isStamp,\n\n  convertConstructor: convertConstructor\n});\n\n},{\"./mixinchain.js\":3,\"mout/array/forEach\":4,\"mout/array/map\":5,\"mout/object/forOwn\":17,\"mout/object/merge\":19,\"mout/object/mixIn\":20}]},{},[1]);\n"],"file":"main.js","sourceRoot":"/source/"}